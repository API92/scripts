import glob
import json
import os
import os.path
import ycm_core
import sys

def FindUp(basename, dir):
    while True:
        if os.path.exists(os.path.join(dir, basename)):
            return dir
        par = os.path.dirname(dir)
        if par == dir:
            return None
        dir = par


def ProjectDirFor(filename):
    return FindUp('CMakeLists.txt', os.path.dirname(filename))

# Set this to the absolute path to the folder (NOT the file!) containing the
# compile_commands.json file to use that instead of 'flags'. See here for
# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html
#
# You can get CMake to generate this file for you by adding:
#   set( CMAKE_EXPORT_COMPILE_COMMANDS 1 )
# to your CMakeLists.txt file.
#
# Most projects will NOT need to set this to anything; you can just change the
# 'flags' list of compilation flags. Notice that YCM itself uses that approach.

COMPCOM = 'compile_commands.json'
databases = {}
sources_by_proj_and_name = {}


def ReadDatabase(db_dir):
    global databases
    if db_dir and os.path.exists(os.path.join(db_dir, COMPCOM)):
        databases[db_dir] = ycm_core.CompilationDatabase(db_dir)
        with open(os.path.join(db_dir, COMPCOM), 'rb') as f:
            cc = json.load(f)
            for src in cc:
                fn = src['file']
                basename = os.path.splitext(os.path.basename(fn))[0]
                sources_by_proj_and_name\
                    .setdefault(ProjectDirFor(fn), {})\
                    .setdefault(basename, set())\
                    .add(os.path.normpath(fn))


def IsHeaderFile(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.h', '.hxx', '.hpp', '.hh', '']


def GetCompilationInfoForFileFromAnyDatabase(filename):
    for db in databases.values():
        inf = db.GetCompilationInfoForFile(filename)
        if inf.compiler_flags_ and len(inf.compiler_flags_):
            return inf
    return None


def GetCompilationInfoForFile(filename):
# The compilation_commands.json file generated by CMake does not have entries
# for header files. So we do our best by asking the db for flags for a
# corresponding source file, if any. If one exists, the flags for that file
# should be good enough.
    if not IsHeaderFile(filename):
        return GetCompilationInfoForFileFromAnyDatabase(filename)

    proj_dir = ProjectDirFor(filename)
    basename = os.path.splitext(os.path.basename(filename))[0]
    if proj_dir not in sources_by_proj_and_name:
        return []
    proj_sources = sources_by_proj_and_name[proj_dir]
    if basename in proj_sources:
        best_replacement, best_len = None, 0
        for src in proj_sources[basename]:
            common = os.path.commonprefix([src, filename])
            if len(common) > best_len:
                best_replacement, best_len = src, len(common)
        return GetCompilationInfoForFileFromAnyDatabase(best_replacement)

    some_replacement = next(iter(next(iter(proj_sources.values()))))
    return GetCompilationInfoForFileFromAnyDatabase(some_replacement)


def MakeRelativePathsInFlagsAbsolute(flags, working_directory):
    if not working_directory:
        return list(flags)
    new_flags = []
    make_next_absolute = False
    path_flags = ['-isystem', '-I', '-iquote', '--sysroot=']
    for flag in flags:
        new_flag = flag

        if make_next_absolute:
            make_next_absolute = False
            if not flag.startswith('/'):
                new_flag = os.path.join( working_directory, flag )

        for path_flag in path_flags:
            if flag == path_flag:
                make_next_absolute = True
                break

            if flag.startswith(path_flag):
                path = flag[len(path_flag):]
                new_flag = path_flag + os.path.join(working_directory, path)
                break

        if new_flag:
            new_flags.append(new_flag)
    return new_flags


def FlagsForFile(filename, **kwargs):
    global databases
    db_dir = FindUp(COMPCOM, os.path.dirname(filename))
    if db_dir not in databases:
        ReadDatabase(db_dir)
    filename = os.path.normpath(filename)
    # Bear in mind that compilation_info.compiler_flags_ does NOT return a
    # python list, but a "list-like" StringVec object
    compilation_info = GetCompilationInfoForFile(filename)
    if not compilation_info or not len(compilation_info.compiler_flags_):
        ReadDatabase(db_dir) # Needed after updating cmake files.
        compilation_info = GetCompilationInfoForFile(filename)
        if not compilation_info or not len(compilation_info.compiler_flags_):
          return None
  
    final_flags = MakeRelativePathsInFlagsAbsolute(
        compilation_info.compiler_flags_,
        compilation_info.compiler_working_dir_)
  
    return {'flags': final_flags, 'do_cache': True}
